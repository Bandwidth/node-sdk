/* tslint:disable */
/* eslint-disable */
/**
 * Bandwidth
 * Bandwidth\'s Communication APIs
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: letstalk@bandwidth.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { CallRecordingMetadata } from '../models';
// @ts-ignore
import type { RecordingTranscriptions } from '../models';
// @ts-ignore
import type { TranscribeRecording } from '../models';
// @ts-ignore
import type { UpdateCallRecording } from '../models';
// @ts-ignore
import type { VoiceApiError } from '../models';
/**
 * RecordingsApi - axios parameter creator
 * @export
 */
export const RecordingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete the recording information, media and transcription.  Note: After the deletion is requested and a `204` is returned, neither the recording metadata nor the actual media nor its transcription will be accessible anymore. However, the media of the specified recording is not deleted immediately. This deletion process, while transparent and irreversible, can take an additional 24 to 48 hours.
         * @summary Delete Recording
         * @param {string} accountId Your Bandwidth Account ID.
         * @param {string} callId Programmable Voice API Call ID.
         * @param {string} recordingId Programmable Voice API Recording ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecording: async (accountId: string, callId: string, recordingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('deleteRecording', 'accountId', accountId)
            // verify required parameter 'callId' is not null or undefined
            assertParamExists('deleteRecording', 'callId', callId)
            // verify required parameter 'recordingId' is not null or undefined
            assertParamExists('deleteRecording', 'recordingId', recordingId)
            const localVarPath = `/accounts/{accountId}/calls/{callId}/recordings/{recordingId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"callId"}}`, encodeURIComponent(String(callId)))
                .replace(`{${"recordingId"}}`, encodeURIComponent(String(recordingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified recording\'s media.
         * @summary Delete Recording Media
         * @param {string} accountId Your Bandwidth Account ID.
         * @param {string} callId Programmable Voice API Call ID.
         * @param {string} recordingId Programmable Voice API Recording ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecordingMedia: async (accountId: string, callId: string, recordingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('deleteRecordingMedia', 'accountId', accountId)
            // verify required parameter 'callId' is not null or undefined
            assertParamExists('deleteRecordingMedia', 'callId', callId)
            // verify required parameter 'recordingId' is not null or undefined
            assertParamExists('deleteRecordingMedia', 'recordingId', recordingId)
            const localVarPath = `/accounts/{accountId}/calls/{callId}/recordings/{recordingId}/media`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"callId"}}`, encodeURIComponent(String(callId)))
                .replace(`{${"recordingId"}}`, encodeURIComponent(String(recordingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified recording\'s transcription.  Note: After the deletion is requested and a `204` is returned, the transcription will not be accessible anymore. However, it is not deleted immediately. This deletion process, while transparent and irreversible, can take an additional 24 to 48 hours.
         * @summary Delete Transcription
         * @param {string} accountId Your Bandwidth Account ID.
         * @param {string} callId Programmable Voice API Call ID.
         * @param {string} recordingId Programmable Voice API Recording ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecordingTranscription: async (accountId: string, callId: string, recordingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('deleteRecordingTranscription', 'accountId', accountId)
            // verify required parameter 'callId' is not null or undefined
            assertParamExists('deleteRecordingTranscription', 'callId', callId)
            // verify required parameter 'recordingId' is not null or undefined
            assertParamExists('deleteRecordingTranscription', 'recordingId', recordingId)
            const localVarPath = `/accounts/{accountId}/calls/{callId}/recordings/{recordingId}/transcription`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"callId"}}`, encodeURIComponent(String(callId)))
                .replace(`{${"recordingId"}}`, encodeURIComponent(String(recordingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Downloads the specified recording.
         * @summary Download Recording
         * @param {string} accountId Your Bandwidth Account ID.
         * @param {string} callId Programmable Voice API Call ID.
         * @param {string} recordingId Programmable Voice API Recording ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadCallRecording: async (accountId: string, callId: string, recordingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('downloadCallRecording', 'accountId', accountId)
            // verify required parameter 'callId' is not null or undefined
            assertParamExists('downloadCallRecording', 'callId', callId)
            // verify required parameter 'recordingId' is not null or undefined
            assertParamExists('downloadCallRecording', 'recordingId', recordingId)
            const localVarPath = `/accounts/{accountId}/calls/{callId}/recordings/{recordingId}/media`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"callId"}}`, encodeURIComponent(String(callId)))
                .replace(`{${"recordingId"}}`, encodeURIComponent(String(recordingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns metadata for the specified recording.
         * @summary Get Call Recording
         * @param {string} accountId Your Bandwidth Account ID.
         * @param {string} callId Programmable Voice API Call ID.
         * @param {string} recordingId Programmable Voice API Recording ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallRecording: async (accountId: string, callId: string, recordingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getCallRecording', 'accountId', accountId)
            // verify required parameter 'callId' is not null or undefined
            assertParamExists('getCallRecording', 'callId', callId)
            // verify required parameter 'recordingId' is not null or undefined
            assertParamExists('getCallRecording', 'recordingId', recordingId)
            const localVarPath = `/accounts/{accountId}/calls/{callId}/recordings/{recordingId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"callId"}}`, encodeURIComponent(String(callId)))
                .replace(`{${"recordingId"}}`, encodeURIComponent(String(recordingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Downloads the specified transcription. If the recording was multi-channel, then there will be 2 transcripts. The caller/called party transcript will be the first item while [`<PlayAudio>`](/docs/voice/bxml/playAudio) and [`<SpeakSentence>`](/docs/voice/bxml/speakSentence) transcript will be the second item. During a [`<Transfer>`](/docs/voice/bxml/transfer) the A-leg transcript will be the first item while the B-leg transcript will be the second item.
         * @summary Get Transcription
         * @param {string} accountId Your Bandwidth Account ID.
         * @param {string} callId Programmable Voice API Call ID.
         * @param {string} recordingId Programmable Voice API Recording ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingTranscription: async (accountId: string, callId: string, recordingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getRecordingTranscription', 'accountId', accountId)
            // verify required parameter 'callId' is not null or undefined
            assertParamExists('getRecordingTranscription', 'callId', callId)
            // verify required parameter 'recordingId' is not null or undefined
            assertParamExists('getRecordingTranscription', 'recordingId', recordingId)
            const localVarPath = `/accounts/{accountId}/calls/{callId}/recordings/{recordingId}/transcription`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"callId"}}`, encodeURIComponent(String(callId)))
                .replace(`{${"recordingId"}}`, encodeURIComponent(String(recordingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of metadata for the recordings associated with the specified account. The list can be filtered by the optional from, to, minStartTime, and maxStartTime arguments. The list is capped at 1000 entries and may be empty if no recordings match the specified criteria.
         * @summary Get Call Recordings
         * @param {string} accountId Your Bandwidth Account ID.
         * @param {string} [to] Filter results by the &#x60;to&#x60; field.
         * @param {string} [from] Filter results by the &#x60;from&#x60; field.
         * @param {string} [minStartTime] Filter results to recordings which have a &#x60;startTime&#x60; after or including &#x60;minStartTime&#x60; (in ISO8601 format).
         * @param {string} [maxStartTime] Filter results to recordings which have a &#x60;startTime&#x60; before &#x60;maxStartTime&#x60; (in ISO8601 format).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountCallRecordings: async (accountId: string, to?: string, from?: string, minStartTime?: string, maxStartTime?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('listAccountCallRecordings', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/recordings`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (minStartTime !== undefined) {
                localVarQueryParameter['minStartTime'] = minStartTime;
            }

            if (maxStartTime !== undefined) {
                localVarQueryParameter['maxStartTime'] = maxStartTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a (potentially empty) list of metadata for the recordings that took place during the specified call.
         * @summary List Call Recordings
         * @param {string} accountId Your Bandwidth Account ID.
         * @param {string} callId Programmable Voice API Call ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallRecordings: async (accountId: string, callId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('listCallRecordings', 'accountId', accountId)
            // verify required parameter 'callId' is not null or undefined
            assertParamExists('listCallRecordings', 'callId', callId)
            const localVarPath = `/accounts/{accountId}/calls/{callId}/recordings`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"callId"}}`, encodeURIComponent(String(callId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate the transcription for a specific recording. Transcription can succeed only for recordings of length greater than 500 milliseconds and less than 4 hours.
         * @summary Create Transcription Request
         * @param {string} accountId Your Bandwidth Account ID.
         * @param {string} callId Programmable Voice API Call ID.
         * @param {string} recordingId Programmable Voice API Recording ID.
         * @param {TranscribeRecording} transcribeRecording 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcribeCallRecording: async (accountId: string, callId: string, recordingId: string, transcribeRecording: TranscribeRecording, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('transcribeCallRecording', 'accountId', accountId)
            // verify required parameter 'callId' is not null or undefined
            assertParamExists('transcribeCallRecording', 'callId', callId)
            // verify required parameter 'recordingId' is not null or undefined
            assertParamExists('transcribeCallRecording', 'recordingId', recordingId)
            // verify required parameter 'transcribeRecording' is not null or undefined
            assertParamExists('transcribeCallRecording', 'transcribeRecording', transcribeRecording)
            const localVarPath = `/accounts/{accountId}/calls/{callId}/recordings/{recordingId}/transcription`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"callId"}}`, encodeURIComponent(String(callId)))
                .replace(`{${"recordingId"}}`, encodeURIComponent(String(recordingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transcribeRecording, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pause or resume a recording on an active phone call.
         * @summary Update Recording
         * @param {string} accountId Your Bandwidth Account ID.
         * @param {string} callId Programmable Voice API Call ID.
         * @param {UpdateCallRecording} updateCallRecording 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCallRecordingState: async (accountId: string, callId: string, updateCallRecording: UpdateCallRecording, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('updateCallRecordingState', 'accountId', accountId)
            // verify required parameter 'callId' is not null or undefined
            assertParamExists('updateCallRecordingState', 'callId', callId)
            // verify required parameter 'updateCallRecording' is not null or undefined
            assertParamExists('updateCallRecordingState', 'updateCallRecording', updateCallRecording)
            const localVarPath = `/accounts/{accountId}/calls/{callId}/recording`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"callId"}}`, encodeURIComponent(String(callId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCallRecording, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RecordingsApi - functional programming interface
 * @export
 */
export const RecordingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RecordingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete the recording information, media and transcription.  Note: After the deletion is requested and a `204` is returned, neither the recording metadata nor the actual media nor its transcription will be accessible anymore. However, the media of the specified recording is not deleted immediately. This deletion process, while transparent and irreversible, can take an additional 24 to 48 hours.
         * @summary Delete Recording
         * @param {string} accountId Your Bandwidth Account ID.
         * @param {string} callId Programmable Voice API Call ID.
         * @param {string} recordingId Programmable Voice API Recording ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRecording(accountId: string, callId: string, recordingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRecording(accountId, callId, recordingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordingsApi.deleteRecording']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the specified recording\'s media.
         * @summary Delete Recording Media
         * @param {string} accountId Your Bandwidth Account ID.
         * @param {string} callId Programmable Voice API Call ID.
         * @param {string} recordingId Programmable Voice API Recording ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRecordingMedia(accountId: string, callId: string, recordingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRecordingMedia(accountId, callId, recordingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordingsApi.deleteRecordingMedia']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the specified recording\'s transcription.  Note: After the deletion is requested and a `204` is returned, the transcription will not be accessible anymore. However, it is not deleted immediately. This deletion process, while transparent and irreversible, can take an additional 24 to 48 hours.
         * @summary Delete Transcription
         * @param {string} accountId Your Bandwidth Account ID.
         * @param {string} callId Programmable Voice API Call ID.
         * @param {string} recordingId Programmable Voice API Recording ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRecordingTranscription(accountId: string, callId: string, recordingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRecordingTranscription(accountId, callId, recordingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordingsApi.deleteRecordingTranscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Downloads the specified recording.
         * @summary Download Recording
         * @param {string} accountId Your Bandwidth Account ID.
         * @param {string} callId Programmable Voice API Call ID.
         * @param {string} recordingId Programmable Voice API Recording ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadCallRecording(accountId: string, callId: string, recordingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadCallRecording(accountId, callId, recordingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordingsApi.downloadCallRecording']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns metadata for the specified recording.
         * @summary Get Call Recording
         * @param {string} accountId Your Bandwidth Account ID.
         * @param {string} callId Programmable Voice API Call ID.
         * @param {string} recordingId Programmable Voice API Recording ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCallRecording(accountId: string, callId: string, recordingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CallRecordingMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCallRecording(accountId, callId, recordingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordingsApi.getCallRecording']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Downloads the specified transcription. If the recording was multi-channel, then there will be 2 transcripts. The caller/called party transcript will be the first item while [`<PlayAudio>`](/docs/voice/bxml/playAudio) and [`<SpeakSentence>`](/docs/voice/bxml/speakSentence) transcript will be the second item. During a [`<Transfer>`](/docs/voice/bxml/transfer) the A-leg transcript will be the first item while the B-leg transcript will be the second item.
         * @summary Get Transcription
         * @param {string} accountId Your Bandwidth Account ID.
         * @param {string} callId Programmable Voice API Call ID.
         * @param {string} recordingId Programmable Voice API Recording ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecordingTranscription(accountId: string, callId: string, recordingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecordingTranscriptions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecordingTranscription(accountId, callId, recordingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordingsApi.getRecordingTranscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of metadata for the recordings associated with the specified account. The list can be filtered by the optional from, to, minStartTime, and maxStartTime arguments. The list is capped at 1000 entries and may be empty if no recordings match the specified criteria.
         * @summary Get Call Recordings
         * @param {string} accountId Your Bandwidth Account ID.
         * @param {string} [to] Filter results by the &#x60;to&#x60; field.
         * @param {string} [from] Filter results by the &#x60;from&#x60; field.
         * @param {string} [minStartTime] Filter results to recordings which have a &#x60;startTime&#x60; after or including &#x60;minStartTime&#x60; (in ISO8601 format).
         * @param {string} [maxStartTime] Filter results to recordings which have a &#x60;startTime&#x60; before &#x60;maxStartTime&#x60; (in ISO8601 format).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAccountCallRecordings(accountId: string, to?: string, from?: string, minStartTime?: string, maxStartTime?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CallRecordingMetadata>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccountCallRecordings(accountId, to, from, minStartTime, maxStartTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordingsApi.listAccountCallRecordings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a (potentially empty) list of metadata for the recordings that took place during the specified call.
         * @summary List Call Recordings
         * @param {string} accountId Your Bandwidth Account ID.
         * @param {string} callId Programmable Voice API Call ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCallRecordings(accountId: string, callId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CallRecordingMetadata>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCallRecordings(accountId, callId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordingsApi.listCallRecordings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate the transcription for a specific recording. Transcription can succeed only for recordings of length greater than 500 milliseconds and less than 4 hours.
         * @summary Create Transcription Request
         * @param {string} accountId Your Bandwidth Account ID.
         * @param {string} callId Programmable Voice API Call ID.
         * @param {string} recordingId Programmable Voice API Recording ID.
         * @param {TranscribeRecording} transcribeRecording 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transcribeCallRecording(accountId: string, callId: string, recordingId: string, transcribeRecording: TranscribeRecording, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transcribeCallRecording(accountId, callId, recordingId, transcribeRecording, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordingsApi.transcribeCallRecording']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Pause or resume a recording on an active phone call.
         * @summary Update Recording
         * @param {string} accountId Your Bandwidth Account ID.
         * @param {string} callId Programmable Voice API Call ID.
         * @param {UpdateCallRecording} updateCallRecording 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCallRecordingState(accountId: string, callId: string, updateCallRecording: UpdateCallRecording, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCallRecordingState(accountId, callId, updateCallRecording, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordingsApi.updateCallRecordingState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RecordingsApi - factory interface
 * @export
 */
export const RecordingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RecordingsApiFp(configuration)
    return {
        /**
         * Delete the recording information, media and transcription.  Note: After the deletion is requested and a `204` is returned, neither the recording metadata nor the actual media nor its transcription will be accessible anymore. However, the media of the specified recording is not deleted immediately. This deletion process, while transparent and irreversible, can take an additional 24 to 48 hours.
         * @summary Delete Recording
         * @param {string} accountId Your Bandwidth Account ID.
         * @param {string} callId Programmable Voice API Call ID.
         * @param {string} recordingId Programmable Voice API Recording ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecording(accountId: string, callId: string, recordingId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRecording(accountId, callId, recordingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified recording\'s media.
         * @summary Delete Recording Media
         * @param {string} accountId Your Bandwidth Account ID.
         * @param {string} callId Programmable Voice API Call ID.
         * @param {string} recordingId Programmable Voice API Recording ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecordingMedia(accountId: string, callId: string, recordingId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRecordingMedia(accountId, callId, recordingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified recording\'s transcription.  Note: After the deletion is requested and a `204` is returned, the transcription will not be accessible anymore. However, it is not deleted immediately. This deletion process, while transparent and irreversible, can take an additional 24 to 48 hours.
         * @summary Delete Transcription
         * @param {string} accountId Your Bandwidth Account ID.
         * @param {string} callId Programmable Voice API Call ID.
         * @param {string} recordingId Programmable Voice API Recording ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecordingTranscription(accountId: string, callId: string, recordingId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRecordingTranscription(accountId, callId, recordingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Downloads the specified recording.
         * @summary Download Recording
         * @param {string} accountId Your Bandwidth Account ID.
         * @param {string} callId Programmable Voice API Call ID.
         * @param {string} recordingId Programmable Voice API Recording ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadCallRecording(accountId: string, callId: string, recordingId: string, options?: any): AxiosPromise<File> {
            return localVarFp.downloadCallRecording(accountId, callId, recordingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns metadata for the specified recording.
         * @summary Get Call Recording
         * @param {string} accountId Your Bandwidth Account ID.
         * @param {string} callId Programmable Voice API Call ID.
         * @param {string} recordingId Programmable Voice API Recording ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallRecording(accountId: string, callId: string, recordingId: string, options?: any): AxiosPromise<CallRecordingMetadata> {
            return localVarFp.getCallRecording(accountId, callId, recordingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Downloads the specified transcription. If the recording was multi-channel, then there will be 2 transcripts. The caller/called party transcript will be the first item while [`<PlayAudio>`](/docs/voice/bxml/playAudio) and [`<SpeakSentence>`](/docs/voice/bxml/speakSentence) transcript will be the second item. During a [`<Transfer>`](/docs/voice/bxml/transfer) the A-leg transcript will be the first item while the B-leg transcript will be the second item.
         * @summary Get Transcription
         * @param {string} accountId Your Bandwidth Account ID.
         * @param {string} callId Programmable Voice API Call ID.
         * @param {string} recordingId Programmable Voice API Recording ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingTranscription(accountId: string, callId: string, recordingId: string, options?: any): AxiosPromise<RecordingTranscriptions> {
            return localVarFp.getRecordingTranscription(accountId, callId, recordingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of metadata for the recordings associated with the specified account. The list can be filtered by the optional from, to, minStartTime, and maxStartTime arguments. The list is capped at 1000 entries and may be empty if no recordings match the specified criteria.
         * @summary Get Call Recordings
         * @param {string} accountId Your Bandwidth Account ID.
         * @param {string} [to] Filter results by the &#x60;to&#x60; field.
         * @param {string} [from] Filter results by the &#x60;from&#x60; field.
         * @param {string} [minStartTime] Filter results to recordings which have a &#x60;startTime&#x60; after or including &#x60;minStartTime&#x60; (in ISO8601 format).
         * @param {string} [maxStartTime] Filter results to recordings which have a &#x60;startTime&#x60; before &#x60;maxStartTime&#x60; (in ISO8601 format).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountCallRecordings(accountId: string, to?: string, from?: string, minStartTime?: string, maxStartTime?: string, options?: any): AxiosPromise<Array<CallRecordingMetadata>> {
            return localVarFp.listAccountCallRecordings(accountId, to, from, minStartTime, maxStartTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a (potentially empty) list of metadata for the recordings that took place during the specified call.
         * @summary List Call Recordings
         * @param {string} accountId Your Bandwidth Account ID.
         * @param {string} callId Programmable Voice API Call ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallRecordings(accountId: string, callId: string, options?: any): AxiosPromise<Array<CallRecordingMetadata>> {
            return localVarFp.listCallRecordings(accountId, callId, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate the transcription for a specific recording. Transcription can succeed only for recordings of length greater than 500 milliseconds and less than 4 hours.
         * @summary Create Transcription Request
         * @param {string} accountId Your Bandwidth Account ID.
         * @param {string} callId Programmable Voice API Call ID.
         * @param {string} recordingId Programmable Voice API Recording ID.
         * @param {TranscribeRecording} transcribeRecording 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcribeCallRecording(accountId: string, callId: string, recordingId: string, transcribeRecording: TranscribeRecording, options?: any): AxiosPromise<void> {
            return localVarFp.transcribeCallRecording(accountId, callId, recordingId, transcribeRecording, options).then((request) => request(axios, basePath));
        },
        /**
         * Pause or resume a recording on an active phone call.
         * @summary Update Recording
         * @param {string} accountId Your Bandwidth Account ID.
         * @param {string} callId Programmable Voice API Call ID.
         * @param {UpdateCallRecording} updateCallRecording 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCallRecordingState(accountId: string, callId: string, updateCallRecording: UpdateCallRecording, options?: any): AxiosPromise<void> {
            return localVarFp.updateCallRecordingState(accountId, callId, updateCallRecording, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RecordingsApi - object-oriented interface
 * @export
 * @class RecordingsApi
 * @extends {BaseAPI}
 */
export class RecordingsApi extends BaseAPI {
    /**
     * Delete the recording information, media and transcription.  Note: After the deletion is requested and a `204` is returned, neither the recording metadata nor the actual media nor its transcription will be accessible anymore. However, the media of the specified recording is not deleted immediately. This deletion process, while transparent and irreversible, can take an additional 24 to 48 hours.
     * @summary Delete Recording
     * @param {string} accountId Your Bandwidth Account ID.
     * @param {string} callId Programmable Voice API Call ID.
     * @param {string} recordingId Programmable Voice API Recording ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordingsApi
     */
    public deleteRecording(accountId: string, callId: string, recordingId: string, options?: RawAxiosRequestConfig) {
        return RecordingsApiFp(this.configuration).deleteRecording(accountId, callId, recordingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified recording\'s media.
     * @summary Delete Recording Media
     * @param {string} accountId Your Bandwidth Account ID.
     * @param {string} callId Programmable Voice API Call ID.
     * @param {string} recordingId Programmable Voice API Recording ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordingsApi
     */
    public deleteRecordingMedia(accountId: string, callId: string, recordingId: string, options?: RawAxiosRequestConfig) {
        return RecordingsApiFp(this.configuration).deleteRecordingMedia(accountId, callId, recordingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified recording\'s transcription.  Note: After the deletion is requested and a `204` is returned, the transcription will not be accessible anymore. However, it is not deleted immediately. This deletion process, while transparent and irreversible, can take an additional 24 to 48 hours.
     * @summary Delete Transcription
     * @param {string} accountId Your Bandwidth Account ID.
     * @param {string} callId Programmable Voice API Call ID.
     * @param {string} recordingId Programmable Voice API Recording ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordingsApi
     */
    public deleteRecordingTranscription(accountId: string, callId: string, recordingId: string, options?: RawAxiosRequestConfig) {
        return RecordingsApiFp(this.configuration).deleteRecordingTranscription(accountId, callId, recordingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Downloads the specified recording.
     * @summary Download Recording
     * @param {string} accountId Your Bandwidth Account ID.
     * @param {string} callId Programmable Voice API Call ID.
     * @param {string} recordingId Programmable Voice API Recording ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordingsApi
     */
    public downloadCallRecording(accountId: string, callId: string, recordingId: string, options?: RawAxiosRequestConfig) {
        return RecordingsApiFp(this.configuration).downloadCallRecording(accountId, callId, recordingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns metadata for the specified recording.
     * @summary Get Call Recording
     * @param {string} accountId Your Bandwidth Account ID.
     * @param {string} callId Programmable Voice API Call ID.
     * @param {string} recordingId Programmable Voice API Recording ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordingsApi
     */
    public getCallRecording(accountId: string, callId: string, recordingId: string, options?: RawAxiosRequestConfig) {
        return RecordingsApiFp(this.configuration).getCallRecording(accountId, callId, recordingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Downloads the specified transcription. If the recording was multi-channel, then there will be 2 transcripts. The caller/called party transcript will be the first item while [`<PlayAudio>`](/docs/voice/bxml/playAudio) and [`<SpeakSentence>`](/docs/voice/bxml/speakSentence) transcript will be the second item. During a [`<Transfer>`](/docs/voice/bxml/transfer) the A-leg transcript will be the first item while the B-leg transcript will be the second item.
     * @summary Get Transcription
     * @param {string} accountId Your Bandwidth Account ID.
     * @param {string} callId Programmable Voice API Call ID.
     * @param {string} recordingId Programmable Voice API Recording ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordingsApi
     */
    public getRecordingTranscription(accountId: string, callId: string, recordingId: string, options?: RawAxiosRequestConfig) {
        return RecordingsApiFp(this.configuration).getRecordingTranscription(accountId, callId, recordingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of metadata for the recordings associated with the specified account. The list can be filtered by the optional from, to, minStartTime, and maxStartTime arguments. The list is capped at 1000 entries and may be empty if no recordings match the specified criteria.
     * @summary Get Call Recordings
     * @param {string} accountId Your Bandwidth Account ID.
     * @param {string} [to] Filter results by the &#x60;to&#x60; field.
     * @param {string} [from] Filter results by the &#x60;from&#x60; field.
     * @param {string} [minStartTime] Filter results to recordings which have a &#x60;startTime&#x60; after or including &#x60;minStartTime&#x60; (in ISO8601 format).
     * @param {string} [maxStartTime] Filter results to recordings which have a &#x60;startTime&#x60; before &#x60;maxStartTime&#x60; (in ISO8601 format).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordingsApi
     */
    public listAccountCallRecordings(accountId: string, to?: string, from?: string, minStartTime?: string, maxStartTime?: string, options?: RawAxiosRequestConfig) {
        return RecordingsApiFp(this.configuration).listAccountCallRecordings(accountId, to, from, minStartTime, maxStartTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a (potentially empty) list of metadata for the recordings that took place during the specified call.
     * @summary List Call Recordings
     * @param {string} accountId Your Bandwidth Account ID.
     * @param {string} callId Programmable Voice API Call ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordingsApi
     */
    public listCallRecordings(accountId: string, callId: string, options?: RawAxiosRequestConfig) {
        return RecordingsApiFp(this.configuration).listCallRecordings(accountId, callId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate the transcription for a specific recording. Transcription can succeed only for recordings of length greater than 500 milliseconds and less than 4 hours.
     * @summary Create Transcription Request
     * @param {string} accountId Your Bandwidth Account ID.
     * @param {string} callId Programmable Voice API Call ID.
     * @param {string} recordingId Programmable Voice API Recording ID.
     * @param {TranscribeRecording} transcribeRecording 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordingsApi
     */
    public transcribeCallRecording(accountId: string, callId: string, recordingId: string, transcribeRecording: TranscribeRecording, options?: RawAxiosRequestConfig) {
        return RecordingsApiFp(this.configuration).transcribeCallRecording(accountId, callId, recordingId, transcribeRecording, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Pause or resume a recording on an active phone call.
     * @summary Update Recording
     * @param {string} accountId Your Bandwidth Account ID.
     * @param {string} callId Programmable Voice API Call ID.
     * @param {UpdateCallRecording} updateCallRecording 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordingsApi
     */
    public updateCallRecordingState(accountId: string, callId: string, updateCallRecording: UpdateCallRecording, options?: RawAxiosRequestConfig) {
        return RecordingsApiFp(this.configuration).updateCallRecordingState(accountId, callId, updateCallRecording, options).then((request) => request(this.axios, this.basePath));
    }
}

